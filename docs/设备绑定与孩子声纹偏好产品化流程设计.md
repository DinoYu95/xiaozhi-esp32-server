# 设备绑定与孩子声纹、偏好 — 产品化流程设计

本文档描述「家长通过 App 绑定设备 → 录入孩子声纹与偏好 → 设备连 xiaozhi-server 后按声纹匹配孩子、按偏好与记忆个性化」的推荐流程，与当前 xiaozhi-server / 智控台能力对齐，便于产品化落地。

---

## 一、整体关系（谁存什么）

| 角色 | 存什么 | 谁提供 |
|------|--------|--------|
| **设备** | device_id（连接时带在 header） | 固件 / 设备端 |
| **智控台 / 管理后端** | 设备绑定关系、设备下的「孩子」档案、声纹 ID 列表、偏好与 prompt | App 录入 → 写入 manager-api / 智控台 DB |
| **xiaozhi-server** | 不持久存绑定/声纹/偏好；每次连接按 device_id 拉配置，拿到声纹列表与偏好，对话时用「当前说话人」做记忆/智伴的 user_id | 拉取 manager-api 的私有配置 |

即：**绑定关系、孩子档案、声纹 ID、偏好** 都在 **管理端（智控台/manager-api）**；**xiaozhi-server 只消费**，通过「设备私有配置」拿到这些信息并用于声纹匹配和个性化。

---

## 二、推荐流程（端到端）

### 1. 家长在 App 里完成「设备绑定」

- 设备首次上电或未绑定时，通过 **OTA/固件** 拿到 **绑定码**（或二维码），并提示「请用 App 绑定」。
- 家长在 **手机 App** 中：
  - 登录（可选，视业务是否需要账号体系）；
  - 输入绑定码（或扫设备上的码），完成 **设备与账号/家庭的绑定**。
- 绑定成功后，**管理端** 记录：`device_id <-> 家庭/账号`，并可为该设备下发「未绑定」→「已绑定」状态（当前 xiaozhi 已有 `need_bind` + 绑定码播报逻辑，可复用）。

### 2. 家长在 App 里为设备添加「孩子」并录入声纹与偏好

- 在「设备管理 / 家庭成员」中，家长为**该设备**添加一个或多个**孩子档案**，例如：
  - **孩子昵称**（如「小明」）；
  - **声纹**：在 App 内按引导录一段孩子说话，上传到声纹服务，得到 **speaker_id**；
  - **偏好/人设**（可选）：如「喜欢恐龙」「5 岁」「怕打雷」等，可写成一段文字或结构化字段。
- 管理端存储结构建议（概念级）：
  - **设备**：device_id, 绑定状态, 绑定时间, 家庭/账号 id；
  - **孩子档案**（按设备或按家庭）：child_id, 设备 id（或家庭 id）, 昵称, 声纹 speaker_id, 偏好文本（或 JSON）。
- 这样，**拉取设备私有配置时**，可以返回「该设备下所有孩子的声纹列表 + 偏好」，供 xiaozhi-server 使用。

### 3. 设备连接 xiaozhi-server 时如何拿到「声纹 + 偏好」

- 设备连上 **xiaozhi-server** 时带上 **device_id**（如现有 `device-id` header）。
- xiaozhi-server 调用 **get_private_config_from_api(device_id, client_id)**（即现有 `get_agent_models`）拉取该设备的**私有配置**。
- 私有配置中建议包含（与现有字段兼容、可扩展）：
  - **voiceprint**：  
    - `url`：声纹识别服务地址（含 key 等）；  
    - `speakers`：该设备下已录入的孩子列表，每项格式可与现有一致，如 `speaker_id, 昵称, 描述`，便于声纹识别返回 speaker 后映射到「哪个孩子」；  
    - `similarity_threshold`：阈值。
  - **prompt / prompt_template**：可包含「当前孩子偏好」的占位或拼接结果（若当前说话人确定，可把该孩子的偏好拼进 system prompt）。
  - **summaryMemory**（可选）：若希望短期记忆按孩子初始化，可在这里按 child_id 给不同初始摘要。
- 若 **device_id 未绑定**：管理端返回 404 或「未绑定」，xiaozhi-server 置 **need_bind = True**，播报绑定码（现有逻辑），不加载声纹/偏好。

### 4. 对话时「按声纹匹配孩子」并在服务端使用

- **ASR 结果**：若声纹服务启用，ASR 返回内容中可带 **说话人信息**（如 `speaker_id` 或已配置的 speaker 标签）。当前 receiveAudioHandle 已支持解析 JSON 中的 `speaker`，并写入 **conn.current_speaker**。
- **确定「当前孩子」**：  
  - 若本连接配置了 voiceprint 且 ASR 返回了 speaker：  
    - 用 **speaker_id** 在私有配置的 **speakers** 列表里查到对应孩子（child_id 或昵称）；  
    - 将该 **child_id**（或稳定唯一 id）作为本轮的「当前用户」用于记忆与智伴。  
  - 若未识别到声纹或未配置声纹：可回退为 **device_id** 作为当前用户（即当前逻辑：memory role_id = device_id）。
- **记忆与智伴**：  
  - **memory.init_memory(role_id=...)**：  
    - 若希望**按孩子隔离记忆**，则传入 **child_id**（或 device_id + child_id 组合），这样同一设备下多孩记忆分开。  
    - 若暂时不区分孩子，可继续用 **device_id** 作为 role_id。  
  - **调用 zhiban-agent**：请求里 **user_id** 传 **child_id**（或 device_id 当未识别到孩子时），这样智伴侧长期记忆也按孩子隔离。

### 5. 偏好如何参与对话

- **方式一（推荐）**：在私有配置的 **prompt / prompt_template** 里，由管理端或 xiaozhi 根据「当前孩子」拼接一段「孩子偏好」描述（如「当前对话的是小明，5 岁，喜欢恐龙，怕打雷」），这样 LLM/智伴 的 system 里已带偏好，无需改协议。
- **方式二**：在给智伴的请求里增加可选字段 **preferences** 或 **context**，把该孩子的偏好文本传过去，由智伴拼进上下文（需智伴侧小改）。
- **方式三**：短期/长期记忆里已经通过「按 child_id 写记忆」逐渐积累偏好，后续对话自动被记忆召回，无需单独「偏好接口」（仍建议至少 prompt 里带一点基础偏好，冷启动体验更好）。

---

## 三、与现有实现的对应关系

| 现有能力 | 产品化用法 |
|----------|------------|
| **device-id header** | 设备唯一标识，用于拉取私有配置、判断是否绑定。 |
| **get_private_config_from_api(device_id, client_id)** | 扩展返回：该设备的 voiceprint（含该设备下孩子的 speakers）、prompt（可含偏好）、summaryMemory 等。 |
| **need_bind + bind_code** | 设备未绑定时播报绑定码，引导家长在 App 完成绑定。 |
| **private_config.voiceprint** | 声纹服务 url + 该设备下孩子的 speakers 列表（speaker_id, 昵称等），ASR 返回 speaker 后用于解析出 child_id。 |
| **conn.current_speaker** | ASR 返回的说话人，用于解析当前孩子并传给 memory role_id / zhiban user_id。 |
| **memory.init_memory(role_id=self.device_id)** | 可改为 role_id=child_id（或 device_id 当无孩子时），实现按孩子隔离记忆。 |
| **zhiban-agent 请求的 user_id** | 传 child_id（或 device_id），智伴长期记忆按孩子/设备隔离。 |

### 一设备多孩子：现有能否支持

**可以，但「孩子」目前对应为「智能体下的多声纹」，且记忆尚未按人隔离。**

- **绑定模型**：当前是 **一设备 → 一个智能体（agent）**，没有「设备 ↔ 多个孩子」的独立表；多孩子的体现方式是：**该智能体下配置多个声纹**（智控台里为同一智能体添加多条声纹，如小明、小红），即 **一设备 → 一 agent → 多个 voiceprint（多个说话人/孩子）**。
- **声纹与识别**：manager-api 的 `getAgentModels` 已按设备查到 agent 后，用 **getVoiceprintsByAgentId(agentId)** 拉取该智能体下**全部声纹**，拼成 `voiceprint.speakers` 下发给 xiaozhi-server；xiaozhi-server 侧声纹识别会从多名说话人中识别出当前说话人并写入 **conn.current_speaker**。因此 **「一设备多孩子」在「多人识别」层面已支持**：同一设备上多个孩子轮流说话，都能被区分出来。
- **记忆与智伴**：目前 **memory 的 role_id** 和智伴请求的 **user_id** 仍为 **device_id**，即同一设备上所有说话人**共用一个身份**，记忆/长期记忆不按孩子隔离。若要「每个孩子一套记忆」，需按设计文档把 **role_id / user_id** 改为「有 current_speaker（或对应 child_id）时用其标识，否则用 device_id」（见上表「与现有实现的对应关系」及第五节实施建议）。

**结论**：一设备绑定多个孩子在现成实现里可以处理，做法是**该设备绑定的智能体下配置多个声纹**；识别谁在说话已支持，按孩子隔离记忆/智伴需按文档做 role_id、user_id 的扩展。

---

## 四、数据流简图（产品化后）

```
[ 家长 App ]
    │ 绑定设备（绑定码）
    │ 添加孩子 → 录入声纹 → 得到 speaker_id
    │ 填写偏好（文字或表单）
    ▼
[ 管理端 / 智控台 DB ]
    设备 ↔ 家庭；设备下孩子档案：child_id, speaker_id, 昵称, 偏好
    │
    │ 设备拉取私有配置（按 device_id）
    ▼
[ xiaozhi-server ]
    连接时：device_id → 拉取 voiceprint(speakers=该设备孩子列表)、prompt(含偏好)、summaryMemory 等
    对话时：ASR 返回 speaker → 解析为 child_id → memory role_id / zhiban user_id = child_id
    未识别到声纹 → 回退为 device_id
```

---

## 五、实施顺序建议

1. **管理端**：  
   - 设备绑定（已有则复用）；  
   - 设备下「孩子」档案的增删改查、声纹 speaker_id 与偏好字段的录入与存储；  
   - 拉取设备私有配置的接口返回 voiceprint（含该设备 speakers）+ prompt（可含偏好）。
2. **xiaozhi-server**：  
   - 保持「按 device_id 拉私有配置」；  
   - 在解析 ASR 说话人后，将 **current_speaker** 映射为 **child_id**（通过 speakers 配置）；  
   - 将 **memory role_id** 与 **zhiban user_id** 改为「有 child_id 用 child_id，否则 device_id」。
3. **声纹服务**：  
   - 提供「录入声纹并返回 speaker_id」的接口给 App；  
   - 提供「识别音频返回 speaker_id」的接口给 ASR/xiaozhi（若尚未统一，可由 ASR 侧回调或由 xiaozhi 在收到 ASR 结果后再调声纹识别，视现有架构而定）。

按上述流程，即可在现有「设备绑定 + 声纹 + 配置拉取」基础上，完成「家长 App 绑定设备 → 录入孩子声纹与偏好 → 设备通过 xiaozhi-server 按声纹匹配孩子并做个性化」的产品化设计；后续只需在管理端与 xiaozhi 侧按表三逐项对接即可。

---

## 六、支持「一设备多孩子」需调整的模块清单（仅列项，不改代码）

以下列出为支持「一个设备绑定多个孩子、按孩子隔离记忆与身份」需要在各项目里改动的点。**zhiban-agent 为独立服务，其 memory 若当前按 device_id 存储，也需一并调整。**

### 6.1 xiaozhi-server（本仓库 main/xiaozhi-server）

| 模块 / 文件 | 当前行为 | 需调整内容 |
|-------------|----------|------------|
| **core/connection.py** | `_initialize_memory()` 里 `init_memory(role_id=self.device_id)` | 计算「当前用户身份」：有 `current_speaker`（或新增 `current_speaker_id`）时用其作为 role_id，否则用 `device_id`；将该身份存到 conn（如 `conn.role_id`）供记忆/智伴/上报复用。 |
| **core/connection.py** | 调用 `self.llm.response(session_id, dialogue)` 时未传 `user_id` | 调用 LLM（含 ZhibanAgent）时传入 `user_id`：有 child 身份用 child 标识（建议用稳定 id，见下），否则用 `device_id`。 |
| **core/providers/llm/ZhibanAgent/ZhibanAgent.py** | `response` / `response_with_functions` 里 `user_id=kwargs.get("user_id")` | 由调用方（connection）传入 `user_id`，无需改此处逻辑；若调用方不传则仍为 None（即沿用下游默认）。 |
| **core/zhibanAgent/zhiban_agent_client.py** | `chat()` / `chat_stream()` 的 `user_id` 可选，传入 payload | 保持现有接口；确保 connection 调用时传入「当前 child 或 device」的 user_id。 |
| **core/utils/voiceprint_provider.py** | `identify_speaker` 返回 **name**（如「小明」），conn 只存 `current_speaker` | 可选：同时返回或设置 **speaker_id** 到 conn（如 `conn.current_speaker_id`），以便用稳定 id 作为 role_id/user_id（避免同名冲突）。若用 name 作身份，需保证同 agent 下 name 不重复。 |
| **core/providers/memory/base.py** | `init_memory(role_id, ...)`，`self.role_id = role_id` | 无逻辑改动；role_id 由 connection 传入，改为「child 或 device」即可。 |
| **core/providers/memory/mem_local_short/mem_local_short.py** | 短期记忆按 `self.role_id` 读写；`save_memory` 时 `summary_id = session_id or self.role_id` | role_id 改为 child/device 后，短期记忆与总结自然按人隔离；若 manager-api 总结接口按 session_id 维度，需确认 session_id 是否要带 child 信息（见 6.3）。 |
| **core/providers/memory/short_long_memory/short_long_memory.py** | 长期记忆 `_long_add` / `_long_search` 用 `role_id` 作为 user_id | role_id 由 connection 传入为 child/device 后，长期记忆自然按人隔离；无需改本文件逻辑。 |
| **core/providers/memory/mem0ai/mem0ai.py** | `add` / `query` 用 `self.role_id` 作为 user_id | 同上，role_id 由上层传入即可。 |
| **core/utils/prompt_manager.py** | 缓存 key 用 `device_prompt:{device_id}`；拉上下文用 `conn.device_id` | 若要做「按孩子的 prompt/偏好」缓存，需增加维度：例如 key 改为 `device_id + child_id` 或仅 device（看产品是否按孩子区分 prompt）。 |
| **core/utils/output_counter.py** | 按 `(device_id, date)` 统计每日字数 | 若需按孩子限流，需增加 child 维度；否则可保持按设备统计。 |
| **core/providers/intent/intent_llm/intent_llm.py** | 意图缓存 key 用 `conn.device_id + text` | 若希望同一设备不同孩子意图缓存隔离，key 需包含 child 标识；否则可保持现状。 |
| **core/handle/reportHandle.py** | 上报 `mac_address=conn.device_id`, `session_id=conn.session_id` | 若管理端需按孩子查聊天记录，上报需带 child 标识：例如在 body 或扩展字段里加 `speaker_id`/`child_id`；或 session_id 约定为 `device_id + child_id` 等（需与 manager-api 约定）。 |

**小结（xiaozhi-server）**：核心是「**统一身份**」：在 connection 里根据 `current_speaker`/`current_speaker_id` 得到 **child_id**（或回退 device_id），用该身份作为 **memory 的 role_id**、**智伴的 user_id**，以及可选地 **上报/缓存 key** 的维度。

---

### 6.2 zhiban-agent（独立服务，memory 当前按 device_id 存储）

以下为 **zhiban-agent 项目内** 需要配合调整的内容（不在此仓库改代码，仅列项供 zhiban-agent 侧实现）：

| 模块 / 能力 | 当前行为（理解） | 需调整内容 |
|-------------|------------------|------------|
| **Memory 模块（长期/短期）** | 按 device_id（或单一 user_id）存储 / 检索 | 改为按 **user_id** 隔离：xiaozhi-server 会传 `user_id = child_id 或 device_id`，同一 device 下不同 child 对应不同 user_id，memory 的写入与查询均按该 user_id 维度。 |
| **Chat / Session 接口** | 若 session 或 conversation 与 device 绑定 | 若希望「同一设备多孩子」会话隔离，需支持以 **user_id**（即 child_id/device_id）为维度的 session 或 conversation，而不是仅按 device。 |
| **配置 / 下游存储** | 若 DB 或向量库 key 为 device_id | 将 key 或 partition 改为 user_id（由上游传入），保证多孩子数据按 user_id 分桶。 |

**小结（zhiban-agent）**：memory 与会话维度从「按设备」改为「按 user_id」；user_id 由 xiaozhi-server 在请求中传入（child 有则传 child 标识，否则传 device_id），zhiban-agent 内部一律按 user_id 存储与检索即可。

---

### 6.3 manager-api（本仓库 main/manager-api）

| 模块 / 文件 | 当前行为 | 需调整内容 |
|-------------|----------|------------|
| **ConfigServiceImpl.getAgentModels** | 已按设备查 agent，并 `getVoiceprintsByAgentId(agentId)` 拼 `voiceprint.speakers` | 若需「按孩子偏好」：可在返回中为每个 speaker 增加 child_id / 偏好字段，或保持现有 speakers 格式，由 xiaozhi 用 speaker_id/name 映射 child（现有已支持多声纹，可不改）。 |
| **聊天记录 / 总结** | 聊天记录表按 `agent_id + session_id`（及 mac_address 等）；总结按 `sessionId` | 若希望按孩子查记录或按孩子总结：需在记录表或总结维度上增加「用户身份」（如 child_id / speaker_id），或约定 session_id 的生成规则（例如 xiaozhi 传 `device_id + "_" + child_id`）；对应接口与 xiaozhi 上报、save 时传的 session_id/身份保持一致。 |

---

### 6.4 其他（本仓库）

| 项 | 说明 |
|----|------|
| **认证 / 限流** | auth、OTA、vision 等仍按 device_id 即可；若有限流按设备则不变，若要做按孩子限流再增加 child 维度。 |
| **测试页 / 端** | 若需验证「一设备多孩子」，需能模拟多说话人（或多 device-id 分别代表不同孩子），或使用真实多声纹设备测试。 |

---

以上清单覆盖 **xiaozhi-server、zhiban-agent、manager-api** 三侧；按此逐项调整后即可支持「一个设备绑定多个孩子」且记忆与智伴按孩子隔离。
