# 家长端：设备绑定与登录 — 实施清单（先对齐再干活）

本文档只覆盖**登录**与**设备绑定**两块，列出需要做的**建表**与**改代码**项；讨论无异议后直接按此实施。

---

## 一、建表（Liquibase 新增 changeSet）

| 序号 | 表名 | 说明 |
|------|------|------|
| 1 | **parent_user** | 家长端用户。字段：id(BIGINT PK), open_id(VARCHAR), union_id(VARCHAR), **phone(VARCHAR)**，nickname(VARCHAR), avatar_url(VARCHAR), channel(VARCHAR, 如 wechat/mini_program), create_time, update_time。唯一索引 (open_id, channel)。**phone 存加密后的密文**（见下方「手机号加密存储」），唯一索引可建在 phone 密文上或另建 phone_encrypted 字段。 |
| 2 | **parent_user_token** | 家长端登录 token。字段：id(BIGINT PK), parent_user_id(BIGINT), token(VARCHAR), expire_time(DATETIME), channel(VARCHAR), create_time。索引 token、parent_user_id。 |
| 3 | **parent_device_binding** | 家长-设备绑定。字段：id(BIGINT PK), parent_user_id(BIGINT), device_id(VARCHAR, 即 mac), bind_time(DATETIME), bind_source(VARCHAR, 如 code/qrcode), create_time。唯一 (parent_user_id, device_id)。 |

- 新建一个 SQL 文件（如 `202602131000.sql`），在 `db.changelog-master.yaml` 末尾增加对应 changeSet。

### 手机号加密存储（建议）

- **建议**：库表里**不存明文手机号**，改为**可逆加密后存储**（如 AES），密钥放在配置或 sys_params，不落库。这样即使库泄露，没有密钥也无法还原手机号，符合常见合规要求。
- **做法**：
  - 写入时（注册/登录/更新 profile）：先对手机号 **AES 加密**，再写入 `parent_user.phone`（或单独字段 `phone_encrypted`）。
  - 读取时（auth/info、发短信、手机号登录匹配）：从库取出密文，**解密**后再使用或返回脱敏（如 138****8000）给前端。
  - 项目内已有 **xiaozhi.common.utils.AESUtils**（encrypt/decrypt），可复用；密钥用 **sys_params** 或 **application.yml** 配置（如 `parent.phone_encrypt_key`），长度需满足 AES 要求（如 16/24/32 字节）。
- **唯一性与查询**：若需按手机号唯一或按手机号查用户，可用**密文**做唯一索引、按密文查询（同一手机号每次加密结果一致需用固定 IV 或仅用 key 的 ECB/或同一 IV，建议 AES 时使用固定 IV 或 GCM 的同一 nonce 策略，保证同明文同密文）；或对手机号做**不可逆哈希**存另一列用于查重（如 `phone_hash = SHA256(phone+盐)`），密文仅用于解密展示/发短信。简单实现可：同一密钥+固定 IV，保证同明文同密文，即可用密文做唯一索引。
- **Redis 验证码**：发验证码时 Redis 存的 key 仍可用明文 phone（或 hash），仅 DB 存加密；登录校验时用请求里的明文 phone 查 Redis，用明文 phone 查 DB 时需先加密再查，或如上用 phone_hash 列查。

实施时在 **ParentUserService** 内统一：入参明文 -> 加密写库；出库 -> 解密再脱敏返回或用于发短信。

---

## 二、后端代码（manager-api）

### 2.1 家长端鉴权（不走 Shiro oauth2）

| 序号 | 事项 | 说明 |
|------|------|------|
| 1 | **ParentTokenFilter** | 新建 Filter：对 `/parent-api/**` 生效；从 Header 取 token（`Parent-Token` 或 `Authorization: Bearer xxx`）；用 token 查 **parent_user_token** 表，有效则取 parent_user_id 写入 ThreadLocal 或 Request 属性，放行；无效/过期返回 401 JSON。 |
| 2 | **ShiroConfig** | 在 filterMap 中**先于** `/**` 增加：`/parent-api/**` -> 使用上述 Filter（需注册为 Spring Bean 并在 Shiro 的 filter 链里命名为如 `parentToken`，该链不经过 oauth2）。 |
| 3 | **获取当前家长** | 提供工具类或 Bean（如 `ParentContext.getParentUserId()`），从当前请求上下文读取 parent_user_id，供 Controller 使用。 |

说明：/parent-api 下**登录、发验证码**接口不需 token，需在 Filter 内放行（如 `/parent-api/auth/wechat`、`/parent-api/auth/phone/code`、`/parent-api/auth/phone/login` 为 anon）。

---

### 2.2 登录与用户接口

| 序号 | 接口 | 说明 |
|------|------|------|
| 1 | **POST /parent-api/auth/wechat** | Body: `{ "code": "微信code", "channel": "mini_program" }`。后端用 code 调微信接口换 openid/unionid（需配置 appId、secret）；有则查 parent_user，无则插入；生成 token 写 parent_user_token；返回 token + 用户信息。 |
| 2 | **POST /parent-api/auth/phone/code** | Body: `{ "phone": "13800138000" }`。发短信验证码（可复用现有短信或单独实现），Redis 存 phone -> code，TTL 5 分钟；限流 1 分钟 1 次。 |
| 3 | **POST /parent-api/auth/phone/login** | Body: `{ "phone": "13800138000", "code": "123456" }`。校验 Redis 中 code；有则查/建 parent_user，写 token，返回同 wechat。 |
| 4 | **GET /parent-api/auth/info** | 需 token。返回当前家长 parent_user 信息（id, nickname, avatarUrl, phone 等）。 |
| 5 | **PUT /parent-api/auth/profile** | 需 token。Body: `{ "nickname", "avatarUrl", "phone" }`。更新当前家长 parent_user。 |
| 6 | **POST /parent-api/auth/logout** | 需 token。删除当前 token 记录或使过期。 |

需要新增：**ParentAuthController**、**ParentUserService**（及实现）、**ParentUserTokenService**（及实现）；Entity/Dao 见下。微信 code 换 openid 需 HTTP 调微信接口（或已有工具可复用）。

---

### 2.3 设备绑定与列表接口

| 序号 | 接口 | 说明 |
|------|------|------|
| 1 | **POST /parent-api/device/bind** | 需 token。Body: `{ "code": "123456" }`。逻辑：用 code 查 Redis `ota:activation:code:{code}` -> deviceId；再查 `ota:activation:data:{deviceId}` 校验；若 ai_device 已存在则仅写 parent_device_binding；若不存在则**先插入 ai_device**（需默认 agentId，可从 sys_params 读或写死一个），再写 parent_device_binding；删 Redis 两 key。返回 deviceId + message。 |
| 2 | **POST /parent-api/device/unbind** | 需 token。Body: `{ "deviceId": "mac" }`。校验该 device 属于当前家长；删 parent_device_binding。（不删 ai_device，设备仍可被智控台用。） |
| 3 | **GET /parent-api/device/list** | 需 token。查 parent_device_binding 列表（当前 parent_user_id），返回 deviceId、bindTime 等。 |

需要新增：**ParentDeviceController**、**ParentDeviceService**（及实现，内部可调现有 RedisKeys、DeviceService 的 geCodeByDeviceId 等）；parent_device_binding 的 Entity/Dao。

---

### 2.4 Entity、Dao、Service 清单

| 类型 | 名称 | 说明 |
|------|------|------|
| Entity | ParentUserEntity | 对应 parent_user 表 |
| Entity | ParentUserTokenEntity | 对应 parent_user_token 表 |
| Entity | ParentDeviceBindingEntity | 对应 parent_device_binding 表 |
| Dao | ParentUserDao（Mapper） | 查/插/更新 parent_user |
| Dao | ParentUserTokenDao | 查/插/删 token |
| Dao | ParentDeviceBindingDao | 查/插/删 parent_device_binding |
| Service | ParentUserService | 登录、info、profile、logout |
| Service | ParentUserTokenService | 生成/校验 token |
| Service | ParentDeviceService | bind、unbind、list（内部用 Redis + 可选 DeviceService 查 ai_device） |

---

### 2.5 DTO / VO

| 名称 | 用途 |
|------|------|
| ParentWechatLoginDTO | auth/wechat 请求体：code, channel |
| ParentPhoneCodeDTO | auth/phone/code 请求体：phone |
| ParentPhoneLoginDTO | auth/phone/login 请求体：phone, code |
| ParentProfileDTO | auth/profile 请求体：nickname, avatarUrl, phone |
| ParentDeviceBindDTO | device/bind 请求体：code |
| ParentDeviceUnbindDTO | device/unbind 请求体：deviceId |
| ParentLoginVO / ParentUserVO | 登录与 info 返回：token, expireAt, user{ id, nickname, avatarUrl, phone } |
| ParentDeviceItemVO | device/list 每项：deviceId, bindTime 等 |

---

### 2.6 错误码（ErrorCode 新增）

| 常量名 | 值 | 含义 |
|--------|-----|------|
| PARENT_TOKEN_INVALID | 20001 | 家长 token 无效或已过期 |
| PARENT_WECHAT_CODE_INVALID | 20002 | 微信 code 无效 |
| PARENT_PHONE_CODE_INVALID | 20003 | 手机验证码错误 |
| PARENT_BIND_CODE_INVALID | 20004 | 绑定码无效或已过期 |
| PARENT_DEVICE_ALREADY_BOUND | 20005 | 设备已被其他账号绑定 |
| PARENT_DEVICE_NOT_BOUND | 20006 | 设备未绑定或不属于当前家长（解绑时） |

（具体数值与 i18n 可再对齐。）

---

### 2.7 配置项（可选）

- 微信小程序/公众号：**appId、secret**（用于 code 换 openid）；可放 sys_params 或 application.yml。
- 家长绑定设备时若需创建 ai_device：**默认 agentId**（可从 sys_params 如 `parent.default_agent_id` 读取）。

---

## 三、不做的（本阶段）

- 设备主人孩子、孩子档案、孩子偏好、声纹录入：表与接口**不做**，后续再做。
- get_agent_models 扩展（owner_child_id、child_preferences）：本阶段**不改**。
- 小程序/App 前端：不在此清单，只保证后端接口按文档可用。

---

## 四、实施顺序建议

1. 建表（parent_user, parent_user_token, parent_device_binding）+ changelog。  
2. Entity + Dao（Mapper XML 或注解）。  
3. ParentUserTokenService + ParentTokenFilter + ShiroConfig 放行 /parent-api/** 且登录接口 anon。  
4. ParentUserService + ParentAuthController（wechat 可先返回 mock 或固定 openid，再接微信 API）。  
5. ParentDeviceService + ParentDeviceController（bind 复用 Redis 与现有 device 逻辑）。  
6. ErrorCode + 返回格式统一（Result）。

---

若上述清单无异议，我按此顺序直接建表、改代码；有需要调整的项你说一下我改清单再动手。
