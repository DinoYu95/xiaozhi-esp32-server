# 智控台与长短期记忆配置说明

## base_url 填在哪里？需要填啥？

- **不是**「配置角色」页里「记忆」下面的那个大输入框。那个是 **历史记忆（summaryMemory）**，用来写一段初始的短期记忆内容（可选），和 base_url 无关。
- **正确位置**：智控台左侧进 **「模型配置」** → 左侧菜单点 **「记忆」** → 在表格里找到 **「长短期记忆」** → 点该行的 **「编辑」** → 在弹窗里往下找到 **「调用信息」** 区域，会看到三个输入项：
  - **LLM模型**：选/填用于短期摘要的 LLM（如 `LLM_ChatGLMLLM`），一般已有默认。
  - **Mem0 API密钥(可选)**：用官方 Mem0 云时填；自建可不填。
  - **Mem0 自建地址(可选)**：自建 Mem0 时**必填**，例如 `http://47.84.15.224:8000`（换成你自己的 IP:端口）。
- 填好 **「Mem0 自建地址」** 后点保存即可，设备拉配置后就会往你的 Postgres 写长期记忆。

**「调用信息」里三个框分别写啥（长短期记忆）：**

| 表单项 | 填什么 | 自建 Mem0 时 |
|--------|--------|----------------|
| LLM模型 | 短期记忆摘要用的 LLM 的 id，如 `LLM_ChatGLMLLM` | 保持默认或选一个可用的 LLM |
| Mem0 API密钥(可选) | 官方 Mem0 云的 API Key | 可留空 |
| Mem0 自建地址(可选) | 自建 Mem0 服务地址 | **必填**，如 `http://你的IP:8000` |

---

## 核心结论（先看这里）

- **设备连智控台时，Memory 配置只来自智控台，不会用 xiaozhi-server 的 config.yaml。**
- 要在**智控台 → 模型配置 → 记忆 → 编辑「长短期记忆」**里填 **Mem0 自建地址**，长期记忆才会写进你的 Postgres；只在 config.yaml 里加 base_url **不起作用**。
- **data 目录下没有 `.memory_short_long.yaml` 是正常的**：连智控台时短期记忆不落盘，只在内存里，可能通过智控台同步到 agent 的「历史记忆」。

---

## 两套配置：什么时候用谁？

### 1. 用智控台（设备已绑定 agent）

- xiaozhi-server 的 `data/.config.yaml` 里配置了 `manager-api.url`，设备会从智控台拉配置。
- 设备连接后，会调用 **get_agent_models** 拿到**该 agent 的私有配置**。
- 代码里会**用 API 返回的配置覆盖本地的 Memory**：

```text
if private_config.get("Memory", None) is not None:
    self.config["Memory"] = private_config["Memory"]   # 完全覆盖
```

所以此时：
- **Memory 配置 = 智控台里该 agent 用的「记忆模型」对应的那条模型配置**
- 即数据库里 `ai_model_config` 表中 **id = 智控台选的记忆模型 id**（例如 `Memory_short_long_memory`）的 **config_json**
- **config.yaml 里写的 Memory / short_long_memory / base_url 都不会被用上**

### 2. 不用智控台（纯本地 config）

- 没有配 `manager-api.url`，或设备未绑定 agent，则用 **config.yaml + data/.config.yaml** 的合并结果。
- 这时你在 **config.yaml** 里写的 `short_long_memory`、`base_url` 才会生效。
- 短期记忆会写入 **data/.memory_short_long.yaml**（因为 `save_to_file=True`）。

---

## 为什么 data 下没有 .memory_short_long.yaml？

- 设备**从智控台拉配置**时，会设 `read_config_from_api = True`。
- 初始化记忆时：`save_to_file = not read_config_from_api`，即 **save_to_file = False**。
- 设计意图：短期记忆不落盘，由智控台侧（如聊天总结）同步到 agent 的「历史记忆」等。
- 所以：**只要连智控台，就不会在 data 下生成 .memory_short_long.yaml**，这是预期行为。

---

## 正确操作步骤（智控台 + 长短期记忆 + 自建 Mem0）

1. **智控台里给 agent 选「长短期记忆」**  
   - 配置角色 → 记忆 → 选「长短期记忆」→ 保存。（你已完成。）

2. **在智控台里给「长短期记忆」这条模型本身填 base_url（关键）**  
   - 进入 **模型配置**（不是「配置角色」）→ **记忆**。  
   - 在列表里找到 **「长短期记忆」**，点 **编辑**。  
   - 在 **「Mem0 自建地址(可选)」** 里填你的 Mem0 地址，例如：`http://47.84.15.224:8000`。  
   - 保存。

这样智控台数据库里 `Memory_short_long_memory` 的 config_json 才会带 `base_url`，设备拉到的配置里才有 base_url，长期记忆才会往你的 Postgres 写。

3. **（可选）config.yaml**  
   - 你已经在 config.yaml 里加了 short_long_memory 和 base_url，这在**不连智控台、纯本地**时有用。  
   - 连智控台时，**不会**用这里的 Memory 配置，但保留也无妨。

---

## 如何确认当前用的是哪套配置？

- 看 xiaozhi-server 启动/连接日志：
  - 有「异步获取差异化配置成功」且带 Memory 等 → 说明在用**智控台配置**，Memory 以智控台为准。
  - 有「长期记忆未启用: 请在智控台…」→ 说明当前拿到的 Memory 配置里**没有** base_url，需要去智控台「模型配置 → 记忆 → 编辑 长短期记忆」补上 Mem0 自建地址。

---

## 小结

| 项目 | 说明 |
|------|------|
| 配置从哪来 | 连智控台 → Memory 只来自智控台（DB 里该记忆模型的 config_json），**不是** config.yaml |
| base_url 写哪 | 智控台 → **模型配置** → 记忆 → 编辑「长短期记忆」→ 填「Mem0 自建地址」 |
| 为何没有 .memory_short_long.yaml | 连智控台时 `save_to_file=False`，短期记忆不写文件，属正常 |
| config.yaml 里的 short_long_memory | 仅在**不连智控台**时生效；连智控台时可保留，但不会影响 Memory |

按上面在智控台「模型配置 → 记忆 → 长短期记忆」里补上 Mem0 自建地址后，重启或重新拉一次配置再测，Postgres 里应能看到长期记忆数据。

---

## 仍然没有上报到 Mem0 时怎么排查

1. **看 xiaozhi-server 启动/连接后的日志**（一次对话后更好）：
   - 若出现 `short_long_memory 收到配置 keys=..., base_url=(空), ...` → 说明设备拿到的配置里**没有** base_url，长期记忆不会启用。需要：
     - 确认在智控台 **模型配置 → 记忆 → 编辑「长短期记忆」** 里填了「Mem0 自建地址」并保存；
     - 设备**重新连接**或重启 xiaozhi-server 再试（让设备重新拉配置）。
   - 若出现 `长期记忆未启用: 请在智控台…` → 同上，配置里没有 base_url 或 api_key。
   - 若出现 `长期记忆: 正在写入 Mem0, base_url=http://...` → 说明长期已启用，正在请求 Mem0；若接着出现 `长期记忆保存失败: ...`，再看下面的「Mem0 响应」日志，根据状态码/报错查网络或自建 Mem0 服务。

2. **确认自建 Mem0 服务**：
   - 本机可执行：`curl -X POST "http://你的Mem0地址:8000/memories" -H "Content-Type: application/json" -d '{"user_id":"test","messages":[{"role":"user","content":"hello"}]}'`，看是否返回 200 或正常 JSON。
   - 若 curl 都失败，说明地址/端口或 Mem0 服务有问题，先修好再测小智。

3. **智控台模型缓存**：
   - 编辑「长短期记忆」保存后，后端会清该模型缓存；若仍怀疑是旧配置，可重启 **manager-api** 再让设备重连。

---

## POST 成功但 memories 表里查不到记录

小智侧已打出「长期记忆已写入 Mem0」且响应为 `{'results': []}`，说明 **HTTP POST 已成功**，问题在 **Mem0 服务端**：要么没真正写库，要么写到了别处。按下面逐项查。

**小智侧已改为发送 `infer: false`**：不经过 LLM 抽取，直接把对话当记忆写入。这样 Mem0 端一般会走到「Inserting N vectors into collection memories」；若仍没有该日志，多半是 422（body 校验失败）或 Mem0 版本不支持 `infer` 字段（可忽略该字段或升级 Mem0）。

### 1. 看 Mem0 服务端日志（最重要）

在**触发保存记忆的那段时间**（看小智日志时间），查看 **Mem0 进程的终端或日志文件**，是否有：

- **LLM 调用报错**：抽记忆要调 LLM，若 API Key 无效、超时、模型名错，会失败且可能不写库。
- **Embedding 调用报错**：写向量库前要调 embedding，失败则不会插入。
- **数据库报错**：连接 Postgres 失败、权限不足、表不存在等。

若有报错，按报错修（Key、网络、DB 配置等），再试一次对话保存。

### 2. 确认 Mem0 用的库和表

- 确认 Mem0 的 **Postgres 连接**（环境变量或配置里的 `POSTGRES_HOST/PORT/DB`）指向的就是你查的那个库。
- pgvector 的 **collection_name**（如 `POSTGRES_COLLECTION_NAME=memories`）会对应表名；有的版本表名可能是 `memories` 或带前缀。在**同一个库**里执行：

```sql
-- 看当前库里有啥表（含 memories 或 vector）
SELECT tablename FROM pg_tables WHERE schemaname = 'public' AND tablename LIKE '%memor%';
```

确认你查的 `memories` 表就是 Mem0 在写的表。

### 3. 试一下关闭异步（若 Mem0 支持）

若 Mem0 的 API 支持 **同步写库再返回**（例如请求体里 `async_mode: false`），可先改成同步，便于确认是「异步任务失败」还是别的问题。具体看自建 Mem0 的 API 文档或源码里 POST /memories 是否支持该参数。

### 4. 用 curl 直连 Mem0 做对比

在同一台能访问 Mem0 的机器上执行：

```bash
# 与小智请求一致：含 "infer": false，直接存原文、不跑 LLM 抽取
curl -X POST "http://你的Mem0地址:8000/memories" \
  -H "Content-Type: application/json" \
  -d '{"user_id":"curl_test","messages":[{"role":"user","content":"我周末去了公园"},{"role":"assistant","content":"听起来不错"}],"infer":false}'
```

然后到 Postgres 查：

```sql
SELECT * FROM memories WHERE payload->>'user_id' = 'curl_test' ORDER BY (payload->>'created_at') DESC LIMIT 5;
```

- 若 **curl 后能查到 `curl_test`**，说明 Mem0 写库正常，问题更可能是小智发的请求（如消息格式、user_id）或 Mem0 对某类请求的处理有差异。
- 若 **curl 后也查不到**，说明问题在 Mem0 服务端（LLM/embedding/DB），继续看 Mem0 日志和配置。

### 5. 确认 user_id 一致

小智发的 `user_id` 是**设备 ID**（如 `B6:C8:35:D6:10:48`）。查库时不要只按「test」查，要按设备 ID 或查全表：

```sql
SELECT payload->>'user_id' AS user_id, payload->>'created_at' AS created, LEFT(payload::text, 200) FROM memories ORDER BY (payload->>'created_at') DESC NULLS LAST LIMIT 20;
```

总结：**POST 成功但表里没记录，多半是 Mem0 端异步写库失败或写到了别的库/表**。先查 Mem0 日志和 DB 配置，再用 curl 对比一次，一般能定位。
